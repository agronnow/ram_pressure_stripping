!#########################################################
!#########################################################
!#########################################################
!#########################################################
subroutine gravana(x,f,dx,ncell)
  use amr_parameters
  use poisson_parameters
  use cooling_module, ONLY: twopi
  implicit none
  integer ::ncell                         ! Size of input arrays
  real(dp)::dx                            ! Cell size
  real(dp),dimension(1:nvector,1:ndim)::f ! Gravitational acceleration
  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position.
  !================================================================
  ! This routine computes the acceleration using analytical models.
  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units).
  ! f(i,1:ndim) is the gravitational acceleration in user units.
  !================================================================
  integer::i
  real(dp)::r,rx,ry,rz,rho0,xmass,ymass,zmass,phi_nfw

  !emass=2.*boxlen*0.5d0**nlevelmax
  !dmax=1.0/emass/(1.0+emass)**2
  !dmax=rho0/((0.001/R_s)*(1+0.001/R_s)**2)
  rho0 =gravity_params(1)
  xmass = x1_c*boxlen
  ymass = x2_c*boxlen
  zmass = x3_c*boxlen
!  xmass=gravity_params(2)*boxlen
!  ymass=gravity_params(3)*boxlen
!#if NDIM == 3
!  zmass=gravity_params(4)*boxlen
!#endif

  do i=1,ncell
     rx=x(i,1)-xmass
     ry=x(i,2)-ymass
#if NDIM == 3
     rz=x(i,3)-zmass
#else
     rz = 0.0
#endif
     r=sqrt(rx**2+ry**2+rz**2)
     phi_nfw=-10.0*(2*twopi*rho0*R_s**3/r)*dlog(1+r/R_s)
     f(i,1)=phi_nfw*rx/r
     f(i,2)=phi_nfw*ry/r
#if NDIM == 3
     f(i,3)=phi_nfw*rz/r
#endif
  end do

end subroutine gravana
!#########################################################
!#########################################################
!#########################################################
!#########################################################
subroutine phi_ana(rr,pp,ngrid)
  use amr_commons
  use poisson_commons
  implicit none
  integer::ngrid
  real(dp),dimension(1:nvector)::rr,pp
  ! -------------------------------------------------------------------
  ! This routine set up boundary conditions for fine levels.
  ! -------------------------------------------------------------------

  integer :: i
  real(dp):: fourpi

  fourpi=4.D0*ACOS(-1.0D0)

#if NDIM==1
  do i=1,ngrid
     pp(i)=multipole(1)*fourpi/2d0*rr(i)
  end do
#endif
#if NDIM==2
  do i=1,ngrid
     pp(i)=multipole(1)*2d0*log(rr(i))
  end do
#endif
#if NDIM==3
  do i=1,ngrid
     pp(i)=-multipole(1)/rr(i)
  end do
#endif
end subroutine phi_ana
